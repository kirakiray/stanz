{"version":3,"file":"stanz.min.mjs","sources":["../src/public.mjs","../src/watch.mjs","../src/accessor.mjs","../src/array.mjs","../src/main.mjs","../src/base.mjs"],"sourcesContent":["export const getRandomId = () => Math.random().toString(32).slice(2);\n\nconst objectToString = Object.prototype.toString;\nexport const getType = (value) =>\n  objectToString\n    .call(value)\n    .toLowerCase()\n    .replace(/(\\[object )|(])/g, \"\");\n\nexport const isObject = (obj) => {\n  const type = getType(obj);\n  return type === \"array\" || type === \"object\";\n};\n\nconst tickSets = new Set();\nexport function nextTick(callback) {\n  const tickId = `t-${getRandomId()}`;\n  tickSets.add(tickId);\n  Promise.resolve().then(() => {\n    if (tickSets.has(tickId)) {\n      callback();\n      tickSets.delete(tickId);\n    }\n  });\n  return tickId;\n}\nexport const clearTick = (id) => tickSets.delete(id);\n\nexport function debounce(func, wait = 0) {\n  let timeout = null;\n  let hisArgs = [];\n\n  return function (...args) {\n    hisArgs.push(...args);\n\n    if (wait > 0) {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => {\n        func.call(this, hisArgs);\n        hisArgs = [];\n        timeout = null;\n      }, wait);\n    } else {\n      if (timeout === null) {\n        timeout = 1;\n        nextTick(() => {\n          func.call(this, hisArgs);\n          hisArgs = [];\n          timeout = null;\n        });\n      }\n    }\n  };\n}\n\n// Enhanced methods for extending objects\nexport const extend = (_this, proto, descriptor = {}) => {\n  [\n    ...Object.getOwnPropertyNames(proto),\n    ...Object.getOwnPropertySymbols(proto),\n  ].forEach((k) => {\n    const result = Object.getOwnPropertyDescriptor(proto, k);\n    const { configurable, enumerable, writable, get, set, value } = result;\n\n    if (\"value\" in result) {\n      if (_this.hasOwnProperty(k)) {\n        _this[k] = value;\n      } else {\n        Object.defineProperty(_this, k, {\n          enumerable,\n          configurable,\n          writable,\n          ...descriptor,\n          value,\n        });\n      }\n    } else {\n      Object.defineProperty(_this, k, {\n        enumerable,\n        configurable,\n        ...descriptor,\n        get,\n        set,\n      });\n    }\n  });\n\n  return _this;\n};\n","import { getRandomId, debounce } from \"./public.mjs\";\nimport { WATCHS } from \"./main.mjs\";\nconst { assign, freeze } = Object;\n\nclass Watcher {\n  constructor(opts) {\n    assign(this, opts);\n    freeze(this);\n  }\n\n  _getCurrent(key) {\n    let { currentTarget } = this;\n\n    if (/\\./.test(key)) {\n      const matchs = key.split(\".\");\n      key = matchs.pop();\n      currentTarget = currentTarget.get(matchs.join(\".\"));\n    }\n\n    return {\n      current: currentTarget,\n      key,\n    };\n  }\n\n  hasModified(k) {\n    if (this.type === \"array\") {\n      return this.path.includes(this.currentTarget.get(k));\n    }\n\n    if (/\\./.test(k)) {\n      const { current, key } = this._getCurrent(k);\n      const last = this.path.slice(-1)[0];\n      if (current === last) {\n        if (this.name === key) {\n          return true;\n        }\n\n        return false;\n      }\n\n      return this.path.includes(current);\n    }\n\n    if (!this.path.length) {\n      return this.name === k;\n    }\n\n    return this.path.includes(this.currentTarget[k]);\n  }\n\n  hasReplaced(k) {\n    if (this.type !== \"set\") {\n      return false;\n    }\n\n    if (/\\./.test(k)) {\n      const { current, key } = this._getCurrent(k);\n      const last = this.path.slice(-1)[0];\n      if (current === last && this.name === key) {\n        return true;\n      }\n\n      return false;\n    }\n\n    if (!this.path.length && this.name === k) {\n      return true;\n    }\n\n    return false;\n  }\n}\n\nclass Watchers extends Array {\n  constructor(arr) {\n    super(...arr);\n  }\n\n  hasModified(key) {\n    return this.some((e) => e.hasModified(key));\n  }\n\n  hasReplaced(key) {\n    return this.some((e) => e.hasReplaced(key));\n  }\n}\n\nexport const emitUpdate = ({\n  type,\n  currentTarget,\n  target,\n  name,\n  value,\n  oldValue,\n  args,\n  path = [],\n}) => {\n  if (path && path.includes(currentTarget)) {\n    console.warn(\"Circular references appear\");\n    return;\n  }\n\n  let options = {\n    type,\n    target,\n    name,\n    oldValue,\n    value,\n  };\n\n  if (type === \"array\") {\n    delete options.value;\n    options.args = args;\n  }\n\n  if (currentTarget._hasWatchs) {\n    const watcher = new Watcher({\n      currentTarget,\n      ...options,\n      path: [...path],\n    });\n\n    currentTarget[WATCHS].forEach((func) => {\n      func(watcher);\n    });\n  }\n\n  currentTarget._update &&\n    currentTarget.owner.forEach((parent) => {\n      emitUpdate({\n        currentTarget: parent,\n        ...options,\n        path: [currentTarget, ...path],\n      });\n    });\n};\n\nexport default {\n  watch(callback) {\n    const wid = \"w-\" + getRandomId();\n\n    this[WATCHS].set(wid, callback);\n\n    return wid;\n  },\n\n  unwatch(wid) {\n    return this[WATCHS].delete(wid);\n  },\n\n  watchTick(callback, wait) {\n    return this.watch(\n      debounce((arr) => {\n        try {\n          this.xid;\n        } catch (err) {\n          // console.warn(`The revoked object cannot use watchTick : `, this);\n          return;\n        }\n        arr = arr.filter((e) => {\n          try {\n            e.path.forEach((item) => item.xid);\n          } catch (err) {\n            return false;\n          }\n\n          return true;\n        });\n\n        callback(new Watchers(arr));\n      }, wait || 0)\n    );\n  },\n};\n","import { isObject } from \"./public.mjs\";\nimport Stanz, { PROXY, isxdata } from \"./main.mjs\";\nimport { emitUpdate } from \"./watch.mjs\";\n\nconst { defineProperties } = Object;\n\nexport const setData = ({ target, key, value, receiver, type, succeed }) => {\n  let data = value;\n  if (isxdata(data)) {\n    data._owner.push(receiver);\n  } else if (isObject(value)) {\n    const desc = Object.getOwnPropertyDescriptor(target, key);\n    if (!desc || desc.hasOwnProperty(\"value\")) {\n      data = new Stanz(value);\n      data._owner.push(receiver);\n    }\n  }\n\n  const oldValue = receiver[key];\n  const isSame = oldValue === value;\n\n  if (!isSame && isxdata(oldValue)) {\n    clearData(oldValue, receiver);\n  }\n\n  const reval = succeed(data);\n\n  !isSame &&\n    !target.__unupdate &&\n    emitUpdate({\n      type: type || \"set\",\n      target: receiver,\n      currentTarget: receiver,\n      name: key,\n      value,\n      oldValue,\n    });\n\n  return reval;\n};\n\nexport const clearData = (val, target) => {\n  if (isxdata(val)) {\n    const index = val._owner.indexOf(target);\n    if (index > -1) {\n      val._owner.splice(index, 1);\n    } else {\n      console.error({\n        desc: \"This data is wrong, the owner has no boarding object at the time of deletion\",\n        target,\n        mismatch: val,\n      });\n    }\n  }\n};\n\nexport const handler = {\n  set(target, key, value, receiver) {\n    if (typeof key === \"symbol\") {\n      return Reflect.set(target, key, value, receiver);\n    }\n\n    // Set properties with _ prefix directly\n    if (/^_/.test(key)) {\n      if (!target.hasOwnProperty(key)) {\n        defineProperties(target, {\n          [key]: {\n            writable: true,\n            configurable: true,\n            value,\n          },\n        });\n      } else {\n        Reflect.set(target, key, value, receiver);\n      }\n      return true;\n    }\n\n    try {\n      return setData({\n        target,\n        key,\n        value,\n        receiver,\n        succeed(data) {\n          return Reflect.set(target, key, data, receiver);\n        },\n      });\n    } catch (error) {\n      const err = new Error(`failed to set ${key} \\n ${error.stack}`);\n\n      Object.assign(err, {\n        key,\n        value,\n        target: receiver,\n        error,\n      });\n\n      throw err;\n    }\n  },\n  deleteProperty(target, key) {\n    if (/^_/.test(key) || typeof key === \"symbol\") {\n      return Reflect.deleteProperty(target, key);\n    }\n\n    return setData({\n      target,\n      key,\n      value: undefined,\n      receiver: target[PROXY],\n      type: \"delete\",\n      succeed() {\n        return Reflect.deleteProperty(target, key);\n      },\n    });\n  },\n};\n","import { clearData } from \"./accessor.mjs\";\nimport { SELF, PROXY, isxdata } from \"./main.mjs\";\nimport { isObject } from \"./public.mjs\";\nimport { emitUpdate } from \"./watch.mjs\";\n\nconst mutatingMethods = [\n  \"push\",\n  \"pop\",\n  \"shift\",\n  \"unshift\",\n  \"splice\",\n  \"reverse\",\n  \"sort\",\n  \"fill\",\n  \"copyWithin\",\n];\n\nconst holder = Symbol(\"placeholder\");\n\nfunction compareArrays(oldArray, newArray) {\n  const backupNewArray = Array.from(newArray);\n  const backupOldArray = Array.from(oldArray);\n  const deletedItems = [];\n  const addedItems = new Map();\n\n  const oldLen = oldArray.length;\n  for (let i = 0; i < oldLen; i++) {\n    const oldItem = oldArray[i];\n    const newIndex = backupNewArray.indexOf(oldItem);\n    if (newIndex > -1) {\n      backupNewArray[newIndex] = holder;\n    } else {\n      deletedItems.push(oldItem);\n    }\n  }\n\n  const newLen = newArray.length;\n  for (let i = 0; i < newLen; i++) {\n    const newItem = newArray[i];\n    const oldIndex = backupOldArray.indexOf(newItem);\n    if (oldIndex > -1) {\n      backupOldArray[oldIndex] = holder;\n    } else {\n      addedItems.set(i, newItem);\n    }\n  }\n\n  return { deletedItems, addedItems };\n}\n\nconst fn = {};\n\nconst arrayFn = Array.prototype;\n\nmutatingMethods.forEach((methodName) => {\n  if (arrayFn[methodName]) {\n    fn[methodName] = function (...args) {\n      const backupArr = Array.from(this);\n\n      const reval = arrayFn[methodName].apply(this[SELF], args);\n\n      const { deletedItems, addedItems } = compareArrays(backupArr, this);\n\n      // Refactoring objects as proxy instances\n      for (let [key, value] of addedItems) {\n        if (isxdata(value)) {\n          value._owner.push(this);\n        } else if (isObject(value)) {\n          this.__unupdate = 1;\n          this[key] = value;\n          delete this.__unupdate;\n        }\n      }\n\n      for (let item of deletedItems) {\n        clearData(item, this);\n      }\n\n      emitUpdate({\n        type: \"array\",\n        currentTarget: this,\n        target: this,\n        args,\n        name: methodName,\n        oldValue: backupArr,\n      });\n\n      if (reval === this[SELF]) {\n        return this[PROXY];\n      }\n\n      return reval;\n    };\n  }\n});\n\nexport default fn;\n","import { extend, getRandomId } from \"./public.mjs\";\nimport { handler as stanzHandler } from \"./accessor.mjs\";\nimport arrayFn from \"./array.mjs\";\nimport watchFn from \"./watch.mjs\";\nconst { defineProperties, getOwnPropertyDescriptor, entries } = Object;\n\nexport const SELF = Symbol(\"self\");\nexport const PROXY = Symbol(\"proxy\");\nexport const WATCHS = Symbol(\"watchs\");\nexport const ISXDATA = Symbol(\"isxdata\");\n\nexport const isxdata = (val) => val && !!val[ISXDATA];\n\nexport function constructor(data, handler = stanzHandler) {\n  // const proxySelf = new Proxy(this, handler);\n  let { proxy: proxySelf, revoke } = Proxy.revocable(this, handler);\n\n  // Determines the properties of the listener bubble\n  proxySelf._update = 1;\n\n  let watchs;\n\n  defineProperties(this, {\n    xid: { value: data.xid || getRandomId() },\n    // Save all parent objects\n    _owner: {\n      value: [],\n    },\n    owner: {\n      configurable: true,\n      get() {\n        return new Set(this._owner);\n      },\n    },\n    [ISXDATA]: {\n      value: true,\n    },\n    [SELF]: {\n      configurable: true,\n      get: () => this,\n    },\n    [PROXY]: {\n      configurable: true,\n      get: () => proxySelf,\n    },\n    // Save the object of the listener function\n    [WATCHS]: {\n      get: () => watchs || (watchs = new Map()),\n    },\n    _hasWatchs: {\n      get: () => !!watchs,\n    },\n    _revoke: {\n      value: revoke,\n    },\n  });\n\n  Object.keys(data).forEach((key) => {\n    const descObj = getOwnPropertyDescriptor(data, key);\n    let { value, get, set } = descObj;\n\n    if (get || set) {\n      defineProperties(this, {\n        [key]: descObj,\n      });\n    } else {\n      // Set the function directly\n      proxySelf[key] = value;\n    }\n  });\n\n  return proxySelf;\n}\n\nexport default class Stanz extends Array {\n  constructor(data) {\n    super();\n\n    return constructor.call(this, data);\n  }\n\n  // This method is still in the experimental period\n  revoke() {\n    const self = this[SELF];\n\n    if (self._onrevokes) {\n      self._onrevokes.forEach((f) => f());\n      self._onrevokes.length = 0;\n    }\n\n    self.__unupdate = 1;\n\n    self[WATCHS].clear();\n\n    entries(this).forEach(([name, value]) => {\n      if (isxdata(value)) {\n        this[name] = null;\n      }\n    });\n\n    self._owner.forEach((parent) => {\n      entries(parent).forEach(([name, value]) => {\n        if (value === this) {\n          parent[name] = null;\n        }\n      });\n    });\n\n    delete self[SELF];\n    delete self[PROXY];\n    self._revoke();\n  }\n\n  toJSON() {\n    let obj = {};\n\n    let isPureArray = true;\n    let maxId = 0;\n\n    Object.keys(this).forEach((k) => {\n      let val = this[k];\n\n      if (!/\\D/.test(k)) {\n        k = parseInt(k);\n        if (k > maxId) {\n          maxId = k;\n        }\n      } else {\n        isPureArray = false;\n      }\n\n      if (isxdata(val)) {\n        val = val.toJSON();\n      }\n\n      obj[k] = val;\n    });\n\n    if (isPureArray) {\n      obj.length = maxId + 1;\n      obj = Array.from(obj);\n    }\n\n    const xid = this.xid;\n    defineProperties(obj, {\n      xid: {\n        get: () => xid,\n      },\n    });\n\n    return obj;\n  }\n\n  toString() {\n    return JSON.stringify(this.toJSON());\n  }\n\n  extend(obj, desc) {\n    return extend(this, obj, desc);\n  }\n\n  get(key) {\n    if (/\\./.test(key)) {\n      const keys = key.split(\".\");\n      let target = this;\n      for (let i = 0, len = keys.length; i < len; i++) {\n        try {\n          target = target[keys[i]];\n        } catch (error) {\n          const err = new Error(\n            `Failed to get data : ${keys.slice(0, i).join(\".\")} \\n${\n              error.stack\n            }`\n          );\n          Object.assign(err, {\n            error,\n            target,\n          });\n          throw err;\n        }\n      }\n\n      return target;\n    }\n\n    return this[key];\n  }\n  set(key, value) {\n    if (/\\./.test(key)) {\n      const keys = key.split(\".\");\n      const lastKey = keys.pop();\n      let target = this;\n      for (let i = 0, len = keys.length; i < len; i++) {\n        try {\n          target = target[keys[i]];\n        } catch (error) {\n          const err = new Error(\n            `Failed to get data : ${keys.slice(0, i).join(\".\")} \\n${\n              error.stack\n            }`\n          );\n          Object.assign(err, {\n            error,\n            target,\n          });\n          throw err;\n        }\n      }\n\n      return (target[lastKey] = value);\n    }\n\n    return (this[key] = value);\n  }\n}\n\nStanz.prototype.extend(\n  { ...watchFn, ...arrayFn },\n  {\n    enumerable: false,\n  }\n);\n","import Stanz, { isxdata } from \"./main.mjs\";\n\nconst stanz = (data) => {\n  return new Stanz(data);\n};\n\nObject.assign(stanz, { is: isxdata });\n\nexport default stanz;\n"],"names":["getRandomId","Math","random","toString","slice","objectToString","Object","prototype","isObject","obj","type","value","call","toLowerCase","replace","tickSets","Set","debounce","func","wait","timeout","hisArgs","args","push","clearTimeout","setTimeout","this","callback","tickId","add","Promise","resolve","then","has","delete","nextTick","assign","freeze","Watcher","constructor","opts","_getCurrent","key","currentTarget","test","matchs","split","pop","get","join","current","hasModified","k","path","includes","name","length","hasReplaced","Watchers","Array","arr","super","some","e","emitUpdate","target","oldValue","console","warn","options","_hasWatchs","watcher","WATCHS","forEach","_update","owner","parent","watchFn","watch","wid","set","unwatch","watchTick","xid","err","filter","item","defineProperties","setData","receiver","succeed","data","isxdata","_owner","desc","getOwnPropertyDescriptor","hasOwnProperty","Stanz","isSame","clearData","reval","__unupdate","val","index","indexOf","splice","error","mismatch","handler","Reflect","writable","configurable","Error","stack","deleteProperty","undefined","PROXY","holder","Symbol","fn","arrayFn","methodName","backupArr","from","apply","SELF","deletedItems","addedItems","oldArray","newArray","backupNewArray","backupOldArray","Map","oldLen","i","oldItem","newIndex","newLen","newItem","oldIndex","compareArrays","entries","ISXDATA","stanzHandler","watchs","proxy","proxySelf","revoke","Proxy","revocable","_revoke","keys","descObj","self","_onrevokes","f","clear","toJSON","isPureArray","maxId","parseInt","JSON","stringify","extend","_this","proto","descriptor","getOwnPropertyNames","getOwnPropertySymbols","result","enumerable","defineProperty","len","lastKey","stanz","is"],"mappings":"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"}