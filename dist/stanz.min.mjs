//! stanz - v8.1.10 https://github.com/kirakiray/stanz  (c) 2018-2023 YAO
const getRandomId=()=>Math.random().toString(32).slice(2),objectToString=Object.prototype.toString,getType=e=>objectToString.call(e).toLowerCase().replace(/(\[object )|(])/g,""),isObject=e=>{const t=(r=e,objectToString.call(r).toLowerCase().replace(/(\[object )|(])/g,""));var r;return"array"===t||"object"===t},tickSets=new Set;function nextTick(e){const t=`t-${getRandomId()}`;return tickSets.add(t),Promise.resolve().then((()=>{tickSets.has(t)&&(e(),tickSets.delete(t))})),t}function debounce(e,t=0){let r=null,s=[];return function(...a){s.push(...a),t>0?(clearTimeout(r),r=setTimeout((()=>{e.call(this,s),s=[],r=null}),t)):null===r&&(r=1,nextTick((()=>{e.call(this,s),s=[],r=null})))}}const extend=(e,t,r={})=>([...Object.getOwnPropertyNames(t),...Object.getOwnPropertySymbols(t)].forEach((s=>{const a=Object.getOwnPropertyDescriptor(t,s),{configurable:n,enumerable:o,writable:i,get:c,set:l,value:h}=a;"value"in a?e.hasOwnProperty(s)?e[s]=h:Object.defineProperty(e,s,{enumerable:o,configurable:n,writable:i,...r,value:h}):Object.defineProperty(e,s,{enumerable:o,configurable:n,...r,get:c,set:l})})),e),{assign:assign,freeze:freeze}=Object;class Watcher{constructor(e){assign(this,e),freeze(this)}_getCurrent(e){let{currentTarget:t}=this;if(/\./.test(e)){const r=e.split(".");e=r.pop(),t=t.get(r.join("."))}return{current:t,key:e}}hasModified(e){if("array"===this.type)return this.path.includes(this.currentTarget.get(e));if(/\./.test(e)){const{current:t,key:r}=this._getCurrent(e);return t===this.path.slice(-1)[0]?this.name===r:this.path.includes(t)}return this.path.length?this.path.includes(this.currentTarget[e]):this.name===e}hasReplaced(e){if("set"!==this.type)return!1;if(/\./.test(e)){const{current:t,key:r}=this._getCurrent(e);return t===this.path.slice(-1)[0]&&this.name===r}return!this.path.length&&this.name===e}}class Watchers extends Array{constructor(e){super(...e)}hasModified(e){return this.some((t=>t.hasModified(e)))}hasReplaced(e){return this.some((t=>t.hasReplaced(e)))}}const emitUpdate=({type:e,currentTarget:t,target:r,name:s,value:a,oldValue:n,args:o,path:i=[]})=>{if(i&&i.includes(t))return void console.warn("Circular references appear");let c={type:e,target:r,name:s,oldValue:n,value:a};if("array"===e&&(delete c.value,c.args=o),t._hasWatchs){const e=new Watcher({currentTarget:t,...c,path:[...i]});t[WATCHS].forEach((t=>{t(e)}))}t._update&&t.owner.forEach((e=>{emitUpdate({currentTarget:e,...c,path:[t,...i]})}))};var watchFn={watch(e){const t="w-"+getRandomId();return this[WATCHS].set(t,e),t},unwatch(e){return this[WATCHS].delete(e)},watchTick(e,t){return this.watch(debounce((t=>{try{this.xid}catch(e){return}t=t.filter((e=>{try{e.path.forEach((e=>e.xid))}catch(e){return!1}return!0})),e(new Watchers(t))}),t||0))}};const{defineProperties:defineProperties$1}=Object,setData=({target:e,key:t,value:r,receiver:s,type:a,succeed:n})=>{let o=r;isxdata(o)?o._owner.push(s):isObject(r)&&(o=new Stanz(r),o._owner.push(s));const i=s[t],c=i===r;!c&&isxdata(i)&&clearData(i,s);const l=n(o);return!c&&!e.__unupdate&&emitUpdate({type:a||"set",target:s,currentTarget:s,name:t,value:r,oldValue:i}),l},clearData=(e,t)=>{if(isxdata(e)){const r=e._owner.indexOf(t);r>-1?e._owner.splice(r,1):console.error({desc:"This data is wrong, the owner has no boarding object at the time of deletion",target:t,mismatch:e})}},handler={set(e,t,r,s){if("symbol"==typeof t)return Reflect.set(e,t,r,s);if(/^_/.test(t))return e.hasOwnProperty(t)?Reflect.set(e,t,r,s):defineProperties$1(e,{[t]:{writable:!0,configurable:!0,value:r}}),!0;try{return setData({target:e,key:t,value:r,receiver:s,succeed:r=>Reflect.set(e,t,r,s)})}catch(e){const a=new Error(`failed to set ${t} \n ${e.stack}`);throw Object.assign(a,{key:t,value:r,target:s,error:e}),a}},deleteProperty:(e,t)=>/^_/.test(t)||"symbol"==typeof t?Reflect.deleteProperty(e,t):setData({target:e,key:t,value:void 0,receiver:e[PROXY],type:"delete",succeed:()=>Reflect.deleteProperty(e,t)})},mutatingMethods=["push","pop","shift","unshift","splice","reverse","sort","fill","copyWithin"],holder=Symbol("placeholder");function compareArrays(e,t){const r=Array.from(t),s=Array.from(e),a=[],n=new Map,o=e.length;for(let t=0;t<o;t++){const s=e[t],n=r.indexOf(s);n>-1?r[n]=holder:a.push(s)}const i=t.length;for(let e=0;e<i;e++){const r=t[e],a=s.indexOf(r);a>-1?s[a]=holder:n.set(e,r)}return{deletedItems:a,addedItems:n}}const fn={},arrayFn=Array.prototype;mutatingMethods.forEach((e=>{arrayFn[e]&&(fn[e]=function(...t){const r=Array.from(this),s=arrayFn[e].apply(this[SELF],t),{deletedItems:a,addedItems:n}=compareArrays(r,this);for(let[e,t]of n)isxdata(t)?t._owner.push(this):isObject(t)&&(this.__unupdate=1,this[e]=t,delete this.__unupdate);for(let e of a)clearData(e,this);return emitUpdate({type:"array",currentTarget:this,target:this,args:t,name:e,oldValue:r}),s===this[SELF]?this[PROXY]:s})}));const{defineProperties:defineProperties,getOwnPropertyDescriptor:getOwnPropertyDescriptor,entries:entries}=Object,SELF=Symbol("self"),PROXY=Symbol("proxy"),WATCHS=Symbol("watchs"),ISXDATA=Symbol("isxdata"),isxdata=e=>e&&!!e[ISXDATA];function constructor(e,t=handler){let r,{proxy:s,revoke:a}=Proxy.revocable(this,t);return s._update=1,defineProperties(this,{xid:{value:e.xid||getRandomId()},_owner:{value:[]},owner:{configurable:!0,get(){return new Set(this._owner)}},[ISXDATA]:{value:!0},[SELF]:{configurable:!0,get:()=>this},[PROXY]:{configurable:!0,get:()=>s},[WATCHS]:{get:()=>r||(r=new Map)},_hasWatchs:{get:()=>!!r},_revoke:{value:a}}),Object.keys(e).forEach((t=>{const r=getOwnPropertyDescriptor(e,t);let{value:a,get:n,set:o}=r;n||o?defineProperties(this,{[t]:r}):s[t]=a})),s}class Stanz extends Array{constructor(e){return super(),constructor.call(this,e)}revoke(){const e=this[SELF];e._onrevokes&&(e._onrevokes.forEach((e=>e())),e._onrevokes.length=0),e.__unupdate=1,e[WATCHS].clear(),entries(this).forEach((([e,t])=>{isxdata(t)&&(this[e]=null)})),e._owner.forEach((e=>{entries(e).forEach((([t,r])=>{r===this&&(e[t]=null)}))})),delete e[SELF],delete e[PROXY],e._revoke()}toJSON(){let e={},t=!0,r=0;Object.keys(this).forEach((s=>{let a=this[s];/\D/.test(s)?t=!1:(s=parseInt(s))>r&&(r=s),isxdata(a)&&(a=a.toJSON()),e[s]=a})),t&&(e.length=r+1,e=Array.from(e));const s=this.xid;return defineProperties(e,{xid:{get:()=>s}}),e}toString(){return JSON.stringify(this.toJSON())}extend(e,t){return extend(this,e,t)}get(e){if(/\./.test(e)){const t=e.split(".");let r=this;for(let e=0,s=t.length;e<s;e++)try{r=r[t[e]]}catch(s){const a=new Error(`Failed to get data : ${t.slice(0,e).join(".")} \n${s.stack}`);throw Object.assign(a,{error:s,target:r}),a}return r}return this[e]}set(e,t){if(/\./.test(e)){const r=e.split("."),s=r.pop();let a=this;for(let e=0,t=r.length;e<t;e++)try{a=a[r[e]]}catch(t){const s=new Error(`Failed to get data : ${r.slice(0,e).join(".")} \n${t.stack}`);throw Object.assign(s,{error:t,target:a}),s}return a[s]=t}return this[e]=t}}Stanz.prototype.extend({...watchFn,...fn},{enumerable:!1});const stanz=e=>new Stanz(e);Object.assign(stanz,{is:isxdata});export{stanz as default};